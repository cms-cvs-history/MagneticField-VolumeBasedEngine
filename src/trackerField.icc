
namespace magField {

bool MagGeometry::trackerField(const GlobalPoint& gp, GlobalVector& bvec) const {

//
//    B-field in Tracker volume
//    
//     In:   xyz[3]: coordinates (m)
//    Out:  bxyz[3]: Bx,By,Bz    (kG)
//
//    Valid for r<1.2 and |z|<3.0               V.Karimäki 040301
//                                 Updated for CMSSW field 070424
//

// b0=field at centre, l=solenoid length, a=radius (m) (phenomen. parameters) 

 static const float b0=40.681, l=15.284, a=4.6430;   // cmssw
 static float ap2=4.0*a*a/(l*l);  
 static float hb0=0.5*b0*sqrt(1.0+ap2);
 static float hlova=1.0/sqrt(ap2);
 static float ainv=2.0*hlova/l;
 float xyz[3];//, bxyz[3];
 xyz[0]=0.01*gp.x();
 xyz[1]=0.01*gp.y();
 xyz[2]=0.01*gp.z();

 float r=sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]);
 float z=xyz[2];
 float az = fabs(z);
 if (r<1.2&&az<3.0) {
  float zainv=z*ainv;
  float rinv=(r>0.0) ? 1.0/r : 0.0;
  float u=hlova-zainv;
  float v=hlova+zainv;
  float fu[5],gv[5];
  ffunkti(u,fu);
  ffunkti(v,gv);
  float rat=r*ainv;
  float corrr=0.00894*r*z*(az-2.2221)*(az-2.2221);
  float corrz=-0.02996*exp(-0.5*(az-1.9820)*(az-1.9820)/(0.78915*0.78915));
  float br=hb0*0.5*rat*(fu[1]-gv[1]-0.125*(fu[3]-gv[3])*rat*rat)+corrr;
  float bz=hb0*(fu[0]+gv[0]-(fu[2]+gv[2])*0.25*rat*rat)+corrz;
  //bxyz[0]=br*xyz[0]*rinv;
  //bxyz[1]=br*xyz[1]*rinv;
  //bxyz[2]=bz;
  ///  GlobalVector bresult(br*xyz[0]*rinv, br*xyz[1]*rinv, bz);
  //  bvec.x()=0.1*br*xyz[0]*rinv;
  //bvec.y()=0.1*br*xyz[1]*rinv;
  //bvec.z()=0.1*bz;
  bvec = 0.1*GlobalVector(br*xyz[0]*rinv, br*xyz[1]*rinv, bz);
  return true;
 }   
 return false;
 // {
 // cout <<"The point is outside the region r<1.2m && |z|<3.0m"<<endl;
 //}
 //return;
}

void MagGeometry::ffunkti(float u, float* ff) const {
// Function and its 3 derivatives
 float a,b; 
 a=1.0/(1.0+u*u);
 b=sqrt(a);
 ff[0]=u*b;
 ff[1]=a*b;
 ff[2]=-3.0*u*a*ff[1];
 ff[3]=a*ff[2]*((1.0/u)-4.0*u);
 return;
}

} // end of namespace
